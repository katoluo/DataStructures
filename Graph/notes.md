## 第六章 图

### 6.1 图的定义和基本术语

**图的定义** 

> 图(Graph) G由两个集合 *V* (vertex) 和 *E* (edge) ，记为 G = ( *V* , *E* )，其中 *V* 是顶点的有穷非空集合，*E* 是 *V* 中顶点偶对的有穷集合，这些顶点偶对称为边。*V* ( *G* ) 和 *E* ( *G* ) 通常分别表示图 *G* 的顶点集合和边集合，*E* ( *G* ) 可以为空集，*V* ( *G* ) 不可以为空集。 

**有向图** 

> 边集合为有向边的集合，称该图为有向图。有向图中的边也称为弧，表示为：<x,y>；x为有向边的起点，弧尾；y为有向边的终点，弧头。

**无向图** 

> 边集合为无向边的集合，称该图为无向图。表示为(x,y)，是无序的。

**子图** 

> 假设有两个图G = （V，E）和G‘=（V'，E’），如果V'⊆V且E‘⊆E，则称G’为G的子图。
>
> **生成子图：**若有满足V(G') = V(G)的子图G‘，则称其为G的生成子图。



**无向完全图和有向完全图** 

> 对于无向图，若具有n（n - 1）/2条边，则称为无向完全图。对于有向图，若具有n（n - 1）条弧，则称为有向完全图。

**稀疏图和稠密图** 

> 有很少条边或弧的图称为稀疏图，反之称为稠密图。

**权和网** 

> 在实际应用中，每条边可以表上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。

**邻接点** 

> 对于无向图G ，如果图的边（v，v'）∈ E，则称顶点v和v'互为邻接点，即v和v'相邻接。

**度、入度和出度** 

> 顶点v的度是指和v相关联的边的数目，记为TD(v)。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为弧头的弧的数目，记为ID(v)；出度是以顶点v为弧尾的弧的数目，记为OD(v)。

**路径和路径长度** 

> 在无向图中，从顶点v到顶点v'的路径是一个顶点序列。如果G是有向图，则路径也是有向的。路径长度是一条路径上经过的边或弧的数目。

**回路或环** 

> 第一个顶点和最后一个顶点相同的路径称为回路或环。

**简单路径、简单回路或简单环** 

> 序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

**连通、连通图和连通分量** 

> 在无向图中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。如果对图图中任意两个顶点v、v'∈V，v和v'都是连通的，则称G是连通图。所谓连通分量，指的是无向图中的极大连通子图。

> 常见考点：对于n个顶点的无向图G，若G是连通图，则最少有n-1条边；若G是非连通图，最多可能有顶点数为n-1的无向完全图的边数。

**强连通图和强连通分量** 

> 强连通图的定义跟连通图差不多，区别是无向图和有向图。强连通分量指的也是极大强连通子图。

> 常见考点：对于n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）。

**连通图的生成树** 

> 一个极小连通子图,它含有图中全部顶点,但只有足以构成 一 棵树的 n-1 条边,这样的连通子图称为连通图的生成树。

> 若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。

**生成森林** 

> 在非连通图中，连通分量的生成树构成了非连通图的生成森林。

**有向树** 

> 一个顶点的入度为0,其余顶点的入度均为1的有向图，称为有向树。



### 6.3 图的类型定义

> 图是一种数据结构，加上一组基本操作，就构成了抽象数据类型 (**Abstract data type**)。
>
> ADT Graph {
>
> ​	数据对象：V是具有相同特性的数据元素的集合，称为顶点集。
>
> ​	数据关系：
>
> ​		R = { VR }
>
> ​		VR = { <v, w> | v, w $\epsilon$ V 且P( v, w ) <v, w > 表示从v到w的弧，
>
> ​					谓词P ( v, w ) 定义了弧< v, w > 的意义或信息 }
>
> ​		基本操作：
>
> ​			CreateGraph(&G, V, VR)
>
> ​				初始条件：V是图的顶点集，VR是图中弧的集合。
>
> ​				操作结果：按V和VR的定义构造图G。
>
> ​			DestroyGraph(&G)
>
> ​				初始条件：图G存在。
>
> ​				操作结果：销毁图G。
>
> ​			LocateVex(G, u)
>
> ​				初始条件：图G存在，u和G中顶点有相同特征。
>
> ​				操作结果：若G中存在顶点u，则返回该顶点在图中的位置；否则返回其他信息。
>
> ​			GetVex(G, v)
>
> ​				初始条件：图G存在，v是G中某个顶点
>
> ​				操作结果：返回v的值
>
> ​			PutVex(&G, v, value)
>
> ​				初始条件：图G存在，v是G中某个顶点
>
> ​				操作结果：对v赋值value
>
> ​			FirstAdjVex(G, v)
>
> ​				初始条件：图G存在，v是G中某个顶点
>
> ​				操作结果：返回v的第一个邻接顶点。若v在G中没有邻接顶点，则返回“空”。
>
> ​			NextAdjVex(G, v, w)
>
> ​				初始条件：图G存在，v是G中某个顶点，w是v的邻接顶点。
>
> ​				操作结果：返回v的（相对于w的）下一个邻接顶点。若w是v的最后一个邻接点，返回“空”。
>
> ​			InsertVex(&G, v)
>
> ​				初始条件：图G存在，v和图中顶点有相同特征。
>
> ​				操作条件：在图中增添新顶点v。
>
> ​			DeleteArc(&G, v, w)
>
> ​				初始条件：图G存在，v和w是G中两个顶点。
>
> ​				操作结果：在G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。
>
> ​			DFSTraverse(G)
>
> ​				初始条件：图G存在
>
> ​				操作结果：对图进行深度优先遍历，在遍历过程中对每个顶点进行访问一次。
>
> ​			BFSTraverse(G)
>
> ​				初始条件：图G存在
>
> ​				操作结果：对图进行广度优先遍历，在遍历过程中对每个顶点访问一次。
>
> } ADT Graph
>
> 





### 6.4 图的存储结构

#### 邻接矩阵（Adjacency Matrix）

> **1. 邻接矩阵表示法**
>
> **邻接矩阵**是表示顶点之间相邻关系的矩阵。设G（*V*，*E*）是具有**n**个顶点的图，则G的邻接矩阵是具有如下性质的**n**阶方针：
>
> ![latex06](https://github.com/katoluo/DataStructures/raw/master/Graph/images/latex06.png)
>
> 若G是网，则邻接矩阵可以定义为：
>
> ![latex04](https://github.com/katoluo/DataStructures/raw/master/Graph/images/latex04.png)
>
> 例如：
>
> ![latex03](https://github.com/katoluo/DataStructures/raw/master/Graph/images/latex03.png)
>
> 
>
> 其中，$w_i,_j$ 表示边上的权值；$\infty$ 表示计算机允许的、大于所有边上权值的数。
>
> 用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。
>
> 具体实现：[adjacency_matrix.h](https://github.com/katoluo/DataStructures/blob/master/Graph/code/adjacencymatrix/adjacency_matrix.h)
>
> 
>
> **采用邻接矩阵表示法创建无向网 (Undirected graph)**
>
> 算法步骤：
>
> - 输入总顶点数和总边数。
> - 依次输入点的信息存入顶点表中。
> - 初始化邻接矩阵，使每个权值初始化为极大值。
> - 构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。
>
> 具体实现：[adjacency_matrix.cpp](https://github.com/katoluo/DataStructures/blob/master/Graph/code/adjacencymatrix/adjacency_matrix.cpp)
>
> 算法分析：
>
> 该算法的时间复杂度是O($n^2$)。
>
> **邻接矩阵表示法的优缺点**
>
> （1）优点
>
> - 便于判断两个顶点之间是否右边，即根据A[i] [j] = 0 或 1 来判断
>
> - 便于计算各个顶点的度。对于无向图，邻接矩阵第 $i$ 行元素之和就是顶点 $i$ 的度；对于有向图，第 $i$ 行元素之和就是顶点 $i$ 的出度，第 $i$ 列元素之和就是顶点 $i$ 的入度。
>
> （2）缺点
>
> - 不便于增加和删除顶点。
> - 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度($n^2$)
> - 空间复杂度高。如果是有向图，$n$ 个顶点需要$n^2$个单元存储边。如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要$n(n-1)/2$ 个单元即可。但无论以何种方式以何种方式存储，邻接矩阵表示法的空间复杂度均为$O(n^2)$，这对于稀疏图而言尤其浪费空间。
>
> **知识回顾与重点考点**
>
> - 如何计算指定顶点的度、入度、出度（分无向图、有向图来考虑）？时间复杂度如何？
> - 如何找到与顶点相邻的边（入边、出边）？时间复杂度如何？
> - 如何存储带权图？
> - 空间复杂度--$O(|V|)^2$，适合存储稠密图。
> - 无向图的邻接矩阵为对称矩阵，如何压缩存储？
> - 设图G的邻接矩阵为A（矩阵元素为0/1），则$A^n$的元素$A^n[i][j]$等于由顶点$v_i$到顶点$v_j$的长度（路径）为n。
>
> 



#### 邻接表（Adjacency List）

> **1. 邻接表表示法**
>
> **邻接表**是图的一种链式存储结构。在邻接表中，对图中每个顶点$v_i$建立一个单链表，把与$v_i$相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放在有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：表头结点表和边表。
>
> - **表头结点表：** 由所有表头结点以顺序结构的形式存储，以便可以随机访问任 一 顶点的边链表。表头结点包括**数据域** (data) 和**链域** (firstarc) 两部分。其中，数据域用于存储顶点$v_i$的名称或其他有关信息；链域用于指向链表中第 一 个结点（即与顶点 $v_i$ 邻接的第 一 个邻接点）。
> - **边表：** 边链表中边结点包括**邻接点域**（adjvex）、**数据域**（info）和**链域**（nextarc）三部分。其中，邻接点域指示与顶点$v_i$邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点$v_i$邻接的下一条边的结点。
>
> 如下图所示：
>
> ![adjacency_list01.png](https://github.com/katoluo/DataStructures/raw/master/Graph/images/adjacency_list01.png)
>
> 具体实现：[adjacency_list.h](https://github.com/katoluo/DataStructures/blob/master/Graph/code/adjacencylish/adjacency_lish.h)
>
> 
>
> **2. 采用邻接表表示法创建无向图**
>
> 基于上述的邻接表表示法，要创建一个图则需要创建其相应的顶点表和边表。
>
> 算法步骤：
>
> - 输入总顶点数和总边数
> - 一次输入点的信息存入顶点表中，使每个表头节点的指针域初始化为NULL。
> - 创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号$i$和$j$之后，将此边结点分别插入$v_i$和$v_j$对应的两个边链表的头部。
>
> 具体实现：[adjacency_lish.cpp](https://github.com/katoluo/DataStructures/blob/master/Graph/code/adjacencylish/adjacency_lish.cpp)
>
> 算法分析：
>
> 该算法的时间复杂度是$O(n+e)$。
>
> 建立有向图的邻接表与此类似，知识更加简单，每读入一个顶点对序号$<i,j>$，仅需生成一个邻接点序号为$j$的边表节点，并将其插入到$v_i$的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。
>
> **注意：** 一个图的邻接矩阵表示是唯一的，但其邻接表表示不唯一。
>
> **3. 邻接表表示法的优缺点**
>
> （1）优点
>
> - 便于增加和删除顶点。
> - 便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为$O(n+e)$。
> - 空间效率高。对于一个具有$n$个顶点$e$条边的图$G$，若是无向图，则需要$n$个顶点表结点和$2e$个边表结点；若是有向图，则需要$n$个顶点表结点和$e$个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为$O(n+e)$。
>
> （2）缺点
>
> - 不便于判断顶点之间是否有边，要判定$v_i$和$v_j$之间是否有边，就需扫描第$i$个边表，最坏情况下要耗费$O(n)$时间。
> - 不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点$v_i$的度是第$i$个边表中的结点个数。在有向图的邻接表中，第$i$个边表上的结点个数是顶点$v_i$的出度，但求$v_i$的入度较困难，需要遍历个顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。
>
> 
>
> **知识回顾与重要考点**
>
> |               |             邻接表              |      邻接矩阵      |
> | :-----------: | :-----------------------------: | :----------------: |
> |  空间复杂度   | 无向图$O(V+2E)$；有向图$O(V+E)$ |      $O(V^2)$      |
> |   适合用于    |           存储稀疏图            |     存储稠密图     |
> |   表示方式    |             不唯一              |        唯一        |
> | 计算度/出入度 |   计算有向图的度和入度不方便    | 必须遍历对应行或列 |
> |  找相邻的边   |      找有向图的入边不方便       | 必须遍历对应行或列 |
>
> 

### 十字链表（Orthogonal List）

>**十字链表**是有向图的另一种链式存储结构。可以看成是将有向图的邻接表和逆邻接表结合起来得到的一种链表。在十字链表中，对应于有向图中每一条弧有一个结点，对应于每个顶点也有一个结点。这些结点的结构如下图所示。
>
>![orthogonal_lish01](https://github.com/katoluo/DataStructures/raw/master/Graph/images/orthogonal_lish01.png)
>
>在弧结点中有五个域：其中尾域（**tailvex**）和头域（**headvex**）分别指示弧尾和弧头这两个顶点在图中的位置，链域（**hlink**）指向弧头相同的下一条弧，而链域（**tlink**）指向弧尾相同的下一条弧，**info**域指向该弧的相关信息。
>
>头结点有三个域：其中**data**域存储和顶点相关信息；**firstin**和**firstout**为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。
>
>十字链表例子表示，如下图：
>
>![orthogonal_list02](https://github.com/katoluo/DataStructures/raw/master/Graph/images/orthogonal_list02.png)
>
>具体实现：
>
>[orthogonal_list.h](https://github.com/katoluo/DataStructures/blob/master/Graph/code/orthogonal/orthogonal_lish.h)
>
>[orthogonal_list.cpp](https://github.com/katoluo/DataStructures/blob/master/Graph/code/orthogonal/orthogonal_lish.cpp)
>
>

### 邻接多重表（Adjacency MultiList）

>**邻接多重表**是无向图的另一种链式存储结构。虽然邻接表是无向图的一种很有效的存储结构，在邻接表中容易求得顶点和边的各种信息。但是，在邻接表中每一条边$(v_i,v_j)$有两个结点，分别在第$i$个和第$j$个链表中，这给某些图的操作带来不便。
>
>在邻接多重表中，每条边用一个节点表示，它由6个域组成。其中，**mark**为标志域，可用以标记该条边是否被搜索过；**ivex**和**jvex**为该边依附的两个顶点在图中的位置；**ilink**指向下一条依附于顶点**ivex**的边；**jlink**指向下一条依附于顶点**jvex**的边，**info**为指向和边相关的各种信息的指针域。
>
>每个顶点也用一个结点表示，由2个域组成。其中，**data**域存储和该顶点相关的信息，**firstedge**域指示第一条依附于该顶点的边。
>
>如下图所示：
>
>![adjacency_multilist01.png](https://github.com/katoluo/DataStructures/raw/master/Graph/images/adjacency_multilist01.png)
>
>具体代码实现：
>
>[adjacency_multilist.h](https://github.com/katoluo/DataStructures/blob/master/Graph/code/adjacencymultilist/adjacency_multilist.h)
>
>[adjacency_multilist.cpp](https://github.com/katoluo/DataStructures/blob/master/Graph/code/adjacencymultilist/adjacency_multilist.cpp)
>
>
>
>|              |                邻接矩阵                |              邻接表              |   十字链表   |  邻接多重表  |
>| :----------: | :------------------------------------: | :------------------------------: | :----------: | :----------: |
>|  空间复杂度  |                $O(V^2)$                | 无向图$O(V+2E)$；有向图$O(V+E)$  |   $O(V+E)$   |   $O(V+E$)   |
>|   找相邻边   |   遍历对应行或列，时间复杂度为$O(V)$   | 找有向图的入边必须遍历整个邻接表 |    很方便    |    很方便    |
>| 删除边或顶点 | 删除边很方便，删除顶点需要大量移动数据 |   无向图中删除边或顶点都不方便   |    很方便    |    很方便    |
>|    适用于    |                 稠密图                 |           稀疏图和其他           | 只能存有向图 | 只能存无向图 |
>|   表示方式   |                  唯一                  |              不唯一              |    不唯一    |    不唯一    |
>
>

### 6.5 图的遍历

#### 广度优先搜索（Breadth First Search，BFS）

>**1. 广度优先搜索遍历的过程**
>
>- 从图中某个顶点$v$出发，访问$v$。
>- 依次访问$v$的各个未曾访问过的邻接点。
>- 分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复步骤3,直至图中所有已被访问的顶点的邻接点都被访问到。
>
>**2. 广度优先搜索遍历的算法实现**
>
>算法步骤：
>
>- 从图中某个顶点$v$出发，访问$v$，并置$visited[v]$的值为$true$，然后将$v$进队。
>
>- 只要队列不空，则重复下述操作：
>
>  队头顶点$u$出队；
>
>  依次检查$u$的所有邻接点$w$，如果$visited[w]$的值为$false$，则访问$w$，并置$visited[w]$的值为$true$，然后将$w$进队。
>
>具体实现：[adjacency_list.cpp](https://github.com/katoluo/DataStructures/blob/master/Graph/code/adjacencylish/adjacency_lish.cpp)
>
>复杂度分析：
>
>- 邻接矩阵存储的图：访问$V$个顶点需要$O(V)$的时间，查找每个顶点的邻接点都需要$O(V$的时间，而总共有$V$个顶点，时间复杂度等于$O(V^2)$。
>- 邻接表存储的图：访问$V$个顶点需要$O(V)$的时间，查找各个顶点的邻接点共需要$O(E)$的时间，时间复杂度等于$O(V+E)$。
>
>

#### 深度优先搜索（Depth First Search，DFS）

> **1. 深度优先搜索遍历的过程**
>
> 深度优先搜索遍历类似树的先序遍历，是树的先序遍历的推广
>
> 对于一个连通图，深度优先搜索遍历的过程如下：
>
> - 从图中某个顶点$v$出发，访问$v$。
> - 找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。
> - 返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。
> - 重复步骤2和步骤3，直至图中所有顶点都被访问过，搜索结束。
>
> 算法具体实现：[adjacency_list.cpp](https://github.com/katoluo/DataStructures/blob/master/Graph/code/adjacencylish/adjacency_lish.cpp)
>
> 自己的思路：把起点顶点进栈；使用while循环，条件为栈不为空。取栈顶元素，判断是否访问过，如果没有则访问；寻找该栈顶元素在边链表中还未被访问的第一个边结点，找到后进栈，进行下一次循环，若在该栈顶元素的边链表的边结点都访问过了，则在弹出栈顶元素，也就是该元素，然后进行下一次循环。然后应该可以得到正确的深度优先搜索遍历序列。（不知道对不对）
>
> 

### 6.6 图的应用

#### 最小生成树（Minimum Cost Spanning Tree）

>**1. 普里姆算法（Prim）**
>
>- 普里姆算法的构造过程
>
>  假设$N=(V,E)$是连通网，$TE$是$N$上最小生成树中边的集合。
>
>  - $U=$ {$u_0$} $(u_0\epsilon V),TE=$ { }。
>  - 在所有$u\epsilon U,v \epsilon V-U$的边$(u,v)\epsilon E$中找一条权值最小的边$(u_0,v_0)$并入集合$TE$，同时$v_0$并入$U$。
>  - 重复步骤2,直至$U=V$为止
>
>  此时$TE$中必有$n-1$条边，则$T=(V,TE)$为$N$的最小生成树。
>
>  图6.19所示为一个连通网$G_5$从$v_1$开始构造最小生成树的例子。可以看出，普里姆算法逐步增加$U$中的顶点，可称为“**加点法**”
>
>![图6_19.png]()
>
>- 普里姆算法的实现
>
>  假设一个无向网$G$以邻接矩阵形式存储，从顶点$u$出发构造$G$的最小生成树$T$，要求输出$T$的各条边。为实现这个算法需附设一个辅助数组$closedge$，以记录从$U$到$V-U$具有最小权值的边。对每个顶点$V_i\epsilon V-U$，在辅助数组中存在一个相应分量$closedge[i-1]$，它包括两个域：lowcost和adjvex，其中lowcost存储最小边上的权值，adjvex存储最小边在$U$中的那个顶点。显然，$closedge[i-1].lowcost = Min$ {$cost(u_i,v_i)|u\epsilon U$}，其中cost(u,v表示赋于边$(u,v)$的权。
>
>  具体实现：[adjacency_list.cpp]()
>
>**[算法分析]**：假设网中有$n$个顶点，则第一个进行初始化的循环语句的频度为n，第二个循环语句的频度为n-1。其中第二个有两个内循环：其一实在$closedge[v].lowcost$中求最小值，其频度为n-1；其二是重新选择具有最小权值的边，其频度为n。由此，普里姆算法的时间复杂度为$O(n^2)$，与网中的边数无关，因此适用于求稠密网的最小生成树。
>
>**[例子]** 利用该算法，对图6.19(a)所示的连通网$G_5$从顶点$v_1$开始构造最小生成树，给出算法中个参量的变化。
>
>![例子01.png]()
>
>
>
>