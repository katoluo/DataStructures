## 第六章 图

### 6.1 图的定义和基本术语

**图的定义** 

> 图(Graph) G由两个集合 *V* (vertex) 和 *E* (edge) ，记为 G = ( *V* , *E* )，其中 *V* 是顶点的有穷非空集合，*E* 是 *V* 中顶点偶对的有穷集合，这些顶点偶对称为边。*V* ( *G* ) 和 *E* ( *G* ) 通常分别表示图 *G* 的顶点集合和边集合，*E* ( *G* ) 可以为空集，*V* ( *G* ) 不可以为空集。 

**有向图** 

> 边集合为有向边的集合，称该图为有向图。有向图中的边也称为弧，表示为：<x,y>；x为有向边的起点，弧尾；y为有向边的终点，弧头。

**无向图** 

> 边集合为无向边的集合，称该图为无向图。表示为(x,y)，是无序的。

**子图** 

> 假设有两个图G = （V，E）和G‘=（V'，E’），如果V'⊆V且E‘⊆E，则称G’为G的子图。
>
> **生成子图：**若有满足V(G') = V(G)的子图G‘，则称其为G的生成子图。



**无向完全图和有向完全图** 

> 对于无向图，若具有n（n - 1）/2条边，则称为无向完全图。对于有向图，若具有n（n - 1）条弧，则称为有向完全图。

**稀疏图和稠密图** 

> 有很少条边或弧的图称为稀疏图，反之称为稠密图。

**权和网** 

> 在实际应用中，每条边可以表上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。

**邻接点** 

> 对于无向图G ，如果图的边（v，v'）∈ E，则称顶点v和v'互为邻接点，即v和v'相邻接。

**度、入度和出度** 

> 顶点v的度是指和v相关联的边的数目，记为TD(v)。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为弧头的弧的数目，记为ID(v)；出度是以顶点v为弧尾的弧的数目，记为OD(v)。

**路径和路径长度** 

> 在无向图中，从顶点v到顶点v'的路径是一个顶点序列。如果G是有向图，则路径也是有向的。路径长度是一条路径上经过的边或弧的数目。

**回路或环** 

> 第一个顶点和最后一个顶点相同的路径称为回路或环。

**简单路径、简单回路或简单环** 

> 序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

**连通、连通图和连通分量** 

> 在无向图中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。如果对图图中任意两个顶点v、v'∈V，v和v'都是连通的，则称G是连通图。所谓连通分量，指的是无向图中的极大连通子图。

> 常见考点：对于n个顶点的无向图G，若G是连通图，则最少有n-1条边；若G是非连通图，最多可能有顶点数为n-1的无向完全图的边数。

**强连通图和强连通分量** 

> 强连通图的定义跟连通图差不多，区别是无向图和有向图。强连通分量指的也是极大强连通子图。

> 常见考点：对于n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）。

**连通图的生成树** 

> 一个极小连通子图,它含有图中全部顶点,但只有足以构成 一 棵树的 n-1 条边,这样的连通子图称为连通图的生成树。

> 若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。

**生成森林** 

> 在非连通图中，连通分量的生成树构成了非连通图的生成森林。

**有向树** 

> 一个顶点的入度为0,其余顶点的入度均为1的有向图，称为有向树。



### 6.3 图的类型定义

> 图是一种数据结构，加上一组基本操作，就构成了抽象数据类型 (**Abstract data type**)。
>
> ADT Graph {
>
> ​	数据对象：V是具有相同特性的数据元素的集合，称为顶点集。
>
> ​	数据关系：
>
> ​		R = { VR }
>
> ​		VR = { <v, w> | v, w $\epsilon$ V 且P( v, w ) <v, w > 表示从v到w的弧，
>
> ​					谓词P ( v, w ) 定义了弧< v, w > 的意义或信息 }
>
> ​		基本操作：
>
> ​			CreateGraph(&G, V, VR)
>
> ​				初始条件：V是图的顶点集，VR是图中弧的集合。
>
> ​				操作结果：按V和VR的定义构造图G。
>
> ​			DestroyGraph(&G)
>
> ​				初始条件：图G存在。
>
> ​				操作结果：销毁图G。
>
> ​			LocateVex(G, u)
>
> ​				初始条件：图G存在，u和G中顶点有相同特征。
>
> ​				操作结果：若G中存在顶点u，则返回该顶点在图中的位置；否则返回其他信息。
>
> }
>
> 
>
> 



### 6.4 图的存储结构

**1. 邻接矩阵（Adjacency Matrix）表示法**

> 邻接矩阵是表示顶点之间相邻关系的矩阵。设G（*V*，*E*）是具有**n**个顶点的图，则G的邻接矩阵是具有如下性质的**n**阶方针：
> $$
> A[i][j] = 
> \begin{cases}
> 1 & 若<v_i,v_j>或(v_i,v_j)\epsilon E \\
> 0 & 反之
> \end{cases}
> $$
> ​	**例如：**
> $$
> \left[
> \begin{matrix}
> 0 & 1 & 1 & 0 \\
> 0 & 0 & 0 & 0 \\
> 0 & 0 & 0 & 0 \\
> 1 & 0 & 0 & 0
> \end{matrix}
> \right]
> $$
> 
>
> 若G是网，则邻接矩阵可以定义为：
> $$
> A[i][j] = 
> \begin{cases}
> w_i,_j & 若<v_i,v_j>或(v_i,v_j) \epsilon E \\
> \infty & 反之
> \end{cases}
> $$
> ​		**例如：**
> $$
> \left[
> \begin{matrix}
> \infty & 5 & \infty & 7 & \infty & \infty \\
> \infty & \infty & 4 & \infty & \infty & \infty \\
> 8 & \infty & \infty & \infty & \infty & \infty \\
> 1 & 2 & 3 & 5 & \infty & \infty
> \end{matrix}
> \right]
> $$
> 
>
> 其中，$w_i,_j$ 表示边上的权值；$\infty$ 表示计算机允许的、大于所有边上权值的数。
>
> 用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。其形式说明如下：
>
> ```cpp
> // --------图的邻接矩阵存储表示--------
> #define MaxInt 32767 // 表示极大值，即无穷
> #define MVNum 100 // 最大顶点数
> typedef char VerTexType; // 假设顶点的数据类型为字符型
> typedef int ArcType; // 假设边的权值类型为整型
> typedef struct
> {
>     VerTexType vexs[MVNum]; // 顶点表
>     ArcType arcs[MVNum][MVNum]; // 邻接矩阵
>     int vexnum, arcnum; // 图的当前顶点数和边数
> } AMGraph; 
> ```
>
> **采用邻接矩阵表示法创建无向网 (Undirected graph)**
>
> 算法步骤：
>
> - 输入总顶点数和总边数。
> - 依次输入点的信息存入顶点表中。
> - 初始化邻接矩阵，使每个权值初始化为极大值。
> - 构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。
>
> 算法描述：
>
> ```cpp
> Status CreateUDN(AMGraph &G) // Undirected graph
> { // 采用邻接矩阵表示法，创建无向网G
>     std::cin >> G.vexnum >> G.arcnum; // 输入总顶点数，总边数
>     for (int i = 0; i != G.vexnum; ++i) // 依次输入点的信息
>         std::cin >> G.vexs[i];
>     for (int i = 0; i != G.vexnum; ++i) // 初始化邻接矩阵，边的权值均置为极大值
>         for (int j = 0; j != G.vexnum; ++j)
>             G.arcs[i][j] = MaxInt;
>     for (int k = 0; k != G.arcnum; ++k) // 构造邻接矩阵
>     {
>         VerTexType v1, v2;
>         ArcType w;
>         std::cin >> v1 >> v2 >> w; // 输入一条边依附的顶点及权值
>         int i = LocateVex(G, v1);
>         int j = LocateVex(G, v2); // 确定v1和v2的G中的位置，即顶点数组的下标
>         G.arcs[i][j] = w; // 边v1-v2的权值置为w
>         G.arcs[j][i] = G.arcs[i][j]; // 置对称边的权值为w
>     }
>     return OK;
> }
> ```
>
> 

- **邻接表**
- **十字链表**
- **邻接多重表**